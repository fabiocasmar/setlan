#!/usr/bin/env python
# -*- coding: utf-8 -*-

####
#CI3725 - Etapa 1 - Análisis Lexicográfico
#Fabio, Castro, 10-10132
#Antonio, Scaramazza 11-10957
####

import ply.lex as lex

# Palabras reservadas del lenguaje
reserved = {
    # lenguaje
    'program' : 'Program',

    # tipos
    'int' : 'Int',
    'bool' : 'Bool',
    'set' : 'Set',

    ## valores
    'true' : 'True',
    'false' : 'False',

    # instrucciones
    'using' : 'Using',
    'in' : 'In',

    ## condicionales
    'if' : 'If',
    'else' : 'Else',

    ## lazos
    'repeat' : 'Repeat',
    'while' : 'While',

    'do': 'Do',

    'for' : 'For',

    ## entrada/salida
    'scan' : 'Scan',

    'print' : 'Print',
    'println' : 'PrintLn',

    # expresiones/operadores
    'or' : 'Or',
    'and' : 'And',
    'not' : 'Not',

    ## funciones
    'def' : 'Def',
    'return': 'Return'
}

# Tokens a ser reconocidos
tokens = [
    # Lenguaje
    'Number',
    'Comma',
    'SemiColon',
    'Assign',

    # Identificadores
    'ID',

    # Instrucciones
    'Arrow',
    'String',

    # Expresiones/Operadores
        # Operadores de Conjuntos
            'SetPlus',
            'SetMinus',
            'SetTimes',
            'SetMod',
            'SetDivition',
            'SetMax',
            'SetMin',
            'SetLen',
            'SetIntersection',
            'SetUnion',
            'SetDifference',
        # Operadores de Enteros
            'Plus',
            'Minus',
            'Times',
            'Divide',
            'Module',
        #  Operadores Booleanos
            'Less',
            'LessEq',
            'Great',
            'GreatEq',
            'Equal',
            'UnEqual',
            # Operadores Booleanos sobre Conjuntos
                'SetBelong',   
        #  Parentizacion
           'OpenParen',
           'CloseParen',
           'OpenCurly',
           'CloseCurly'
] + list(reserved.values())

# Devuelve el valor almacenado en el tipo entero de Python
def t_Number(t):
    r'\d+'
    val = int(t.value)
    if val > 2147483648:
        error_NUMBER(t)
    t.value = val
    return t

t_Comma = r','
t_SemiColon = r';'
t_Assign = r'='

def t_ID(t):
    r'\w[\w\d]*'
    # Si no existen palabras reservadas que concuender, entonces es un Identificador
    t.type = reserved.get(t.value, 'ID')
    return t

t_Arrow = r'->'

# Los Strings almacenan toda entrada sin importar los saltos de linea
# Siempre que estas esten entre " "

t_STRING = r'\"([^\\\n]|(\\(n|"|\\)))*?\"'

# token de conjuntos
t_SetPlus = r'\<\+\>'
t_SetMinus = r'\<\-\>'
t_SetTimes = r'\<\*\>'
t_SetDivition = r'\<\/\>'
t_SetMod = r'\<\%\>'
t_SetMax = r'\>\?'
t_SetMin = r'\<\?'
t_SetLen = r'\$\?'
t_SetIntersection = r'\>\<'
t_SetUnion = r'\+\+'
t_SetDifference = r'\\'

# token de entero
t_Plus = r'\+'
t_Minus = r'-'
t_Times = r'\*'
t_Divide = r'/'
t_Module = r'%'

# token de booleano
t_Less = r'\<'
t_LessEq = r'\<\='
t_Great = r'\>'
t_GreatEq = r'\>\='
t_Equal = r'\=\='
t_UnEqual = r'\/\='

#token de booleano sobre entero
t_SetBelong = r'\@'

# parentizacion
t_OpenParen = r'\('
t_CloseParen = r'\)'
t_OpenCurly = r'\{'
t_CloseCurly = r'\}'

# Ignora espacion, tabuladores y comentarios en formato C
t_ignore = " \t"
t_ignore_COMMENT = r'\#.*'

# El unico caracter de salto de linea a conciderar es "\n"
def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count('\n')

# Determinar el numero de columna en la linea actual
def find_column(text,token):
    last_cr = text.rfind('\n',0,token.lexpos)
    if last_cr < 0:
        last_cr = -1
    column = token.lexpos - last_cr
    return column

# Error a mostrar en caso de encontrar un caracter inseperado
def t_error(token):
    text = token.lexer.lexdata
    message = "Error: Se encontró un caracter inesperado '%s' en la línea %d, columna %d"    r'\d+'
    val = int(token.value)
    if val > 2147483648:
        error_NUMBER(token)

    token.value = val
    return token
    data = (token.value[0], token.lineno, find_column(text, token))
    lexer_error.append(message % data)
    token.lexer.skip(1)


# Error a mostrar número, número muy grande
def error_NUMBER(token):
    text = token.lexer.lexdata
    message = "Error: Overflow for int '%s' at line %d, column %d"
    data = (token.value, token.lineno, find_column(text, token))
    lexer_error.append(message % data)


# Build the lexer
lex.lex()
lexer_error = []

###############################################################################


# The file (stored in a Python String)
# goes through the lexer and returns the list of tokens
def lexing(file_string, debug=0):

    lexer = lex.lex()
    tokens_list = []

    lexer.input(file_string, debug=debug)

    # Pass entire file through lexer
    for tok in lexer:
        tokens_list.append(tok)

    # If no "Unexpected character" or "Overflow" was found
    if not lexer_error:
        return tokens_list
    else:
        # Print all the errors
        for error in lexer_error:
            print error

        # Empty list to indicate error
        return []


# Only to be called if this is the main module
def main(argv=None):
    import sys      # argv, exit

    if argv is None:
        argv = sys.argv

    if len(argv) == 1:
        print "ERROR: No input file"
        return
    elif len(argv) > 3:
        print "ERROR: Invalid number of arguments"
        return

    if len(argv) == 3:
        debug = argv[2]
    else:
        debug = 0

    # Opens file to interpret
    file_string = open(argv[1], 'r').read()

    # Reads the file and passes it to the Lexer
    tokens_list = lexing(file_string, debug)

    for tok in tokens_list:
        print 'tok(' + str(tok.type) + ')' + '            '[:-(len(tok.type))],
        print 'val(' + str(tok.value) + ')',
        print 'at line ' + str(tok.lineno) + ',',
        print 'column ' + str(find_column(file_string, tok))


# If this is the module running
if __name__ == "__main__":
    main()